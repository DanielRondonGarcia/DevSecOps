name: DevSecOps Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

permissions:
  contents: read
  packages: write
  security-events: write
  actions: read
  issues: write
  pull-requests: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/devsecops

jobs:
  # Job 1: Build and Test
  build-and-test:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Shallow clones should be disabled for better analysis

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test || echo "No tests configured yet"

      - name: Build application
        run: npm run build || echo "No build script configured"

      - name: Extract metadata for image tagging
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,format=short,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

  # Job 2: SAST - Static Application Security Testing with SonarQube
  sast-sonarqube:
    runs-on: ubuntu-latest
    needs: build-and-test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run tests to generate coverage and test report
        run: npm test

      - name: Show generated test report (debug)
        if: always()
        run: |
          echo "==== Begin coverage/test-reporter.xml ===="
          if [ -f coverage/test-reporter.xml ]; then cat coverage/test-reporter.xml; else echo "coverage/test-reporter.xml not found"; fi
          echo "==== End coverage/test-reporter.xml ===="

      - name: Normalize path separators in test report
        run: |
          if [ -f coverage/test-reporter.xml ]; then
            sed -i 's|\\|/|g' coverage/test-reporter.xml
          fi

      - name: Validate test report XML structure
        run: |
          python - << 'PY'
          import sys
          import xml.etree.ElementTree as ET
          try:
              ET.parse('coverage/test-reporter.xml')
              print('Generic test execution XML is well-formed')
          except Exception as e:
              print('XML validation failed:', e)
              sys.exit(1)
          PY

      - name: Get version from package.json
        id: get-version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectVersion=${{ steps.get-version.outputs.version }}
      # If you wish to fail your job when the Quality Gate is red, uncomment the
      # following lines. This would typically be used to fail a deployment.
      # We do not recommend to use this in a pull request. Prefer using pull request
      # decoration instead.
      - uses: SonarSource/sonarqube-quality-gate-action@v1
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # Job 3: SCA - Software Composition Analysis with Trivy
  sca-trivy:
    runs-on: ubuntu-latest
    needs: build-and-test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build an image from Dockerfile
        run: |
          IMAGE_TAG=$(echo "${{ needs.build-and-test.outputs.image-tag }}" | head -n1)
          docker build -t "${IMAGE_TAG}" .

      - name: Set image tag for Trivy scan
        id: set-tag
        run: |
          IMAGE_TAG=$(echo "${{ needs.build-and-test.outputs.image-tag }}" | head -n1)
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ steps.set-tag.outputs.image-tag }}
          format: "table"
          exit-code: "1"
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"

  # Job 4: IaC Security - Infrastructure as Code Security with Checkov
  iac-security-checkov:
    runs-on: ubuntu-latest
    needs: build-and-test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Checkov GitHub Action
        id: checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          # Escanea los manifiestos en la carpeta k8s
          directory: ./k8s
          framework: kubernetes
          # Soft fail: reporta errores pero no detiene el pipeline
          # Esto es comÃºn para IaC, para revisar antes de bloquear.
          soft_fail: true
          # Genera un reporte en formato SARIF para subirlo a GitHub
          output_format: sarif
          output_file_path: results.sarif

      - name: Upload Checkov scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: results.sarif

  # Job 5: Build and Push Docker Image
  docker-build-push:
    runs-on: ubuntu-latest
    needs: [sast-sonarqube, sca-trivy, iac-security-checkov]
    # Solo se ejecuta en push a main/develop, no en PRs
    if: github.event_name == 'push' && always() && (needs.sast-sonarqube.result == 'success' || needs.sast-sonarqube.result == 'skipped') && (needs.sca-trivy.result == 'success' || needs.sca-trivy.result == 'skipped') && (needs.iac-security-checkov.result == 'success' || needs.iac-security-checkov.result == 'skipped')
    outputs:
      image-url: ${{ steps.meta.outputs.tags }}
      image-tag: ${{ steps.extract_sha_tag.outputs.sha_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,format=short,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract short SHA tag for deployment
        id: extract_sha_tag
        shell: bash
        run: |
          echo "All computed tags:"
          echo "${{ steps.meta.outputs.tags }}"
          SHA_LINE=$(echo "${{ steps.meta.outputs.tags }}" | grep -E ':sha-[0-9a-f]+' | head -n 1 || true)
          if [ -z "$SHA_LINE" ]; then
            echo "No sha-* tag found in metadata tags."
            exit 1
          fi
          SHA_TAG=${SHA_LINE##*:}
          echo "Using SHA tag: $SHA_TAG"
          echo "sha_tag=$SHA_TAG" >> "$GITHUB_OUTPUT"

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  setup-cloudflare-ingress:
    name: Setup Cloudflare Ingress
    runs-on: ubuntu-latest
    needs: [docker-build-push] # Se ejecuta despuÃ©s del build
    # Solo se ejecuta en push a main, no en PRs
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.docker-build-push.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          authkey: ${{ secrets.TAILSCALE_AUTH_KEY }}

      - name: Configure kubectl
        run: |
          mkdir -p ${HOME}/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 --decode > ${HOME}/.kube/config
          chmod 600 ${HOME}/.kube/config

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: "v3.13.1" # O la versiÃ³n que prefieras

      - name: Create Cloudflare tunnel secret
        run: |
          # 1. Obtenemos el token del secreto de GitHub
          TUNNEL_TOKEN="${{ secrets.CF_TUNNEL_TOKEN }}"

          # 2. Creamos el archivo credentials.json con el formato correcto
          echo '{"AccountTag":"","TunnelSecret":"","TunnelID":"9dff4c32-7941-49b4-a170-e6010c597c81"}' > credentials.json

          # 3. Creamos el secreto con el archivo credentials.json y el token
          kubectl create secret generic tunnel-credentials \
            --namespace=devsecops \
            --from-file=credentials.json=credentials.json \
            --from-literal=token="${{ secrets.CF_TUNNEL_TOKEN }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "Cloudflare tunnel secret created/updated successfully."

      - name: Deploy Cloudflare Tunnel
        run: |
          # Crear el namespace primero
          kubectl apply -f k8s/namespace.yml
          # Aplicar el deployment directo de cloudflared
          kubectl apply -f k8s/cloudflared-deployment.yml
          echo "Cloudflare tunnel deployment applied successfully."

  # Job 6: Deploy Application for DAST Testing
  deploy-to-kubernetes:
    runs-on: ubuntu-latest
    needs: [setup-cloudflare-ingress]
    environment: production
    # Solo se ejecuta en push a main, no en PRs
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      app-url: ${{ steps.get-app-url.outputs.url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Connect to Tailscale
        uses: tailscale/github-action@v3
        with:
          authkey: ${{ secrets.TAILSCALE_AUTH_KEY }}
          tags: "tag:ci-runner"

      - name: Configure kubectl
        run: |
          mkdir -p ${HOME}/.kube
          # Decodifica el secreto y escribe el archivo de configuraciÃ³n
          echo "${{ secrets.KUBE_CONFIG }}" | base64 --decode > ${HOME}/.kube/config
          chmod 600 ${HOME}/.kube/config

      - name: Convert repository name to lowercase
        id: string-utils
        uses: ASzc/change-string-case-action@v6
        with:
          string: ${{ github.repository }}

      - name: Create Image Pull Secret in Kubernetes
        run: |
          # Este comando es idempotente, no fallarÃ¡ si el secreto ya existe
          kubectl create secret docker-registry ghcr-secret \
            --namespace=devsecops \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.IMAGE_REGISTRY_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Update image tag in Kubernetes manifest
        run: |
          # CAMBIO CLAVE: Calculamos la etiqueta corta aquÃ­ mismo, eliminando la dependencia de 'outputs'.
          GIT_SHA_SHORT=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="sha-$GIT_SHA_SHORT"

          # Convertir el owner a minÃºsculas
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')

          # PASO DE DEPURACIÃ“N: Imprimimos la imagen completa para verificar en los logs
          echo "Full image name to be applied: ghcr.io/$OWNER_LOWER/devsecops:$IMAGE_TAG"

          # Usamos sed para reemplazar el placeholder
          sed -i "s#IMAGE_PLACEHOLDER#ghcr.io/$OWNER_LOWER/devsecops:$IMAGE_TAG#g" k8s/deployment.yml

      - name: Apply Kubernetes manifests
        run: |
          sleep 1
          # Aplicar network policy para seguridad
          kubectl apply -f k8s/network-policy.yml
          kubectl apply -f k8s/deployment.yml
          kubectl apply -f k8s/service.yml
          kubectl apply -f k8s/ingress.yml
          echo "Deployment successful!"

      - name: Get application URL
        id: get-app-url
        run: |
          # Obtener la URL de la aplicaciÃ³n desde el ingress
          APP_URL="https://app.rondon.cloud"
          echo "url=$APP_URL" >> $GITHUB_OUTPUT
          echo "Application URL: $APP_URL"

      - name: Deploy to Production
        run: |
          echo "ðŸš€ Deploying to production https://app.rondon.cloud"
          echo "Branch: ${{ github.ref }}"
          echo "Commit: ${{ github.sha }}"
          echo "Image: ${{ needs.docker-build-push.outputs.image-url }}"
          # Add your production deployment logic here
          # For example: kubectl, docker-compose, cloud provider CLI, etc.

  # Job 7: DAST - Dynamic Application Security Testing with OWASP ZAP
  dast-owasp-zap:
    runs-on: ubuntu-latest
    needs: sast-sonarqube
    # Se ejecuta siempre despuÃ©s de SAST, tanto en PRs como en main
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine target URL
        id: target-url
        run: |
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            # En main branch, usar la URL de producciÃ³n
            APP_URL="https://app.rondon.cloud"
            echo "Using production URL for main branch: $APP_URL"
          else
            # En PRs, usar una URL de staging o demo
            APP_URL="https://app.rondon.cloud"  # Puedes cambiar esto por una URL de staging
            echo "Using staging/demo URL for PR: $APP_URL"
          fi
          echo "url=$APP_URL" >> $GITHUB_OUTPUT

      - name: Wait for application to be ready
        run: |
          echo "Waiting for application to be fully ready..."
          sleep 30

          # Verificar que la aplicaciÃ³n responda correctamente
          APP_URL="${{ steps.target-url.outputs.url }}"
          echo "Testing application readiness at: $APP_URL"

          # Intentar conectar hasta 5 veces con intervalos de 10 segundos
          for i in {1..5}; do
            if curl -f -s "$APP_URL/health" > /dev/null; then
              echo "Application is ready!"
              break
            else
              echo "Attempt $i: Application not ready yet, waiting..."
              sleep 10
            fi
          done

      - name: ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.12.0
        with:
          target: ${{ steps.target-url.outputs.url }}
          rules_file_name: ".zap/rules.tsv"
          cmd_options: "-a -d -T 60"
        continue-on-error: true

      - name: Create ZAP report directory
        run: |
          GIT_SHA_SHORT=$(echo ${{ github.sha }} | cut -c1-7)
          mkdir -p zap-reports-$GIT_SHA_SHORT

      - name: ZAP Full Scan
        uses: zaproxy/action-full-scan@v0.10.0
        with:
          target: ${{ needs.deploy-to-kubernetes.outputs.app-url }}
          rules_file_name: ".zap/rules.tsv"
          cmd_options: "-a -j -d -T 120"
        continue-on-error: true

      - name: Process ZAP Results
        if: always()
        run: |
          echo "Processing ZAP scan results..."

          # Usar el directorio dinÃ¡mico creado anteriormente
          GIT_SHA_SHORT=$(echo ${{ github.sha }} | cut -c1-7)
          REPORT_DIR="zap-reports-$GIT_SHA_SHORT"

          # Verificar si existen los archivos de reporte
          if [ -f "report_html.html" ]; then
            cp report_html.html "$REPORT_DIR/"
            echo "HTML report found and copied"
          fi

          if [ -f "report_json.json" ]; then
            cp report_json.json "$REPORT_DIR/"
            echo "JSON report found and copied"

            # Extraer estadÃ­sticas bÃ¡sicas del JSON
            if command -v jq &> /dev/null; then
              echo "=== ZAP Scan Summary ==="
              jq -r '.site[0].alerts[] | "Alert: \(.name) - Risk: \(.riskdesc) - Confidence: \(.confidence)"' report_json.json | head -10
            fi
          fi

          if [ -f "report_md.md" ]; then
            cp report_md.md "$REPORT_DIR/"
            echo "Markdown report found and copied"
          fi

      - name: Upload ZAP scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-security-reports-${{ github.sha }}
          path: |
            report_html.html
            report_json.json
            report_md.md
            zap-reports-*/
          retention-days: 30

      - name: Comment ZAP Results on PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            let comment = '## ðŸ”’ DAST Security Scan Results\n\n';

            if (fs.existsSync('report_json.json')) {
              const report = JSON.parse(fs.readFileSync('report_json.json', 'utf8'));
              const alerts = report.site[0]?.alerts || [];

              const highRisk = alerts.filter(a => a.riskcode === '3').length;
              const mediumRisk = alerts.filter(a => a.riskcode === '2').length;
              const lowRisk = alerts.filter(a => a.riskcode === '1').length;

              comment += `### Security Issues Found:\n`;
              comment += `- ðŸ”´ High Risk: ${highRisk}\n`;
              comment += `- ðŸŸ¡ Medium Risk: ${mediumRisk}\n`;
              comment += `- ðŸŸ¢ Low Risk: ${lowRisk}\n\n`;

              if (highRisk > 0) {
                comment += `âš ï¸ **High risk vulnerabilities detected!** Please review the security report.\n`;
              } else {
                comment += `âœ… No high risk vulnerabilities detected.\n`;
              }
            } else {
              comment += 'ZAP scan completed but no detailed results available.\n';
            }

            comment += '\nDetailed reports are available in the workflow artifacts.';

            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              console.log('Comment posted successfully');
            } catch (error) {
              console.log('Failed to post comment:', error.message);
              console.log('ZAP scan results are still available in artifacts');
            }

  # Job 8: Security Summary Report
  security-summary:
    runs-on: ubuntu-latest
    needs: [sast-sonarqube, sca-trivy, iac-security-checkov, dast-owasp-zap]
    if: always()
    steps:
      - name: Security Summary
        run: |
          echo "## ðŸ”’ DevSecOps Security Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Security Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---|---|" >> $GITHUB_STEP_SUMMARY
          echo "| SAST (SonarQube) | ${{ needs.sast-sonarqube.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| SCA (Trivy) | ${{ needs.sca-trivy.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| IaC Security (Checkov) | ${{ needs.iac-security-checkov.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| DAST (OWASP ZAP) | ${{ needs.dast-owasp-zap.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š Check the Security tab for detailed vulnerability reports." >> $GITHUB_STEP_SUMMARY
